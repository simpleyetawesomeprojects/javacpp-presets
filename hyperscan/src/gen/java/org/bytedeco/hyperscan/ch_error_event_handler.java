// Targeted by JavaCPP version 1.5.8-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.hyperscan;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.hyperscan.global.hyperscan.*;


/**
 * Definition of the Chimera error event callback function type.
 *
 * A callback function matching the defined type may be provided by the
 * application calling the \ref ch_scan function. This callback function
 * will be invoked when an error event occurs during matching; this indicates
 * that some matches for a given expression may not be reported.
 *
 * @param error_type
 *      The type of error event that occurred. Currently these errors
 *      correspond to resource limits on PCRE backtracking
 *      \ref CH_ERROR_MATCHLIMIT and \ref CH_ERROR_RECURSIONLIMIT.
 *
 * @param id
 *      The ID number of the expression that matched.
 *
 * @param info
 *      Event-specific data, for future use. Currently unused.
 *
 * @param ctx
 *      The context pointer supplied by the user to the \ref ch_scan
 *      function.
 *
 * @return
 *      The callback can return \ref CH_CALLBACK_SKIP_PATTERN to cease matching
 *      this pattern but continue matching the next pattern. Otherwise, we stop
 *      matching for all patterns with \ref CH_CALLBACK_TERMINATE.
 */
 @Properties(inherit = org.bytedeco.hyperscan.presets.hyperscan.class)
public class ch_error_event_handler extends FunctionPointer {
     static { Loader.load(); }
     /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
     public    ch_error_event_handler(Pointer p) { super(p); }
     protected ch_error_event_handler() { allocate(); }
     private native void allocate();
     public native @Cast("ch_callback_t") int call(
                                                  @Cast("ch_error_event_t") int error_type,
                                                  @Cast("unsigned int") int id, Pointer info,
                                                  Pointer ctx);
 }
